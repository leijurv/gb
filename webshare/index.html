<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GB File Download</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            text-align: center;
        }
        h1 { color: #00d4ff; margin-bottom: 10px; font-size: 20px; }
        .filename {
            font-size: 24px;
            margin: 20px 0;
            word-break: break-all;
            color: #fff;
        }
        .meta {
            color: #888;
            font-size: 13px;
            margin-bottom: 20px;
        }
        button {
            padding: 18px 50px;
            border: none;
            border-radius: 6px;
            background: #00d4ff;
            color: #1a1a2e;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #00b8e6; }
        button:disabled { background: #555; cursor: not-allowed; }
        #status {
            margin-top: 25px;
            padding: 15px;
            border-radius: 4px;
            background: #16213e;
            font-size: 14px;
            display: none;
        }
        #status.error { background: #3e1621; color: #ff6b6b; }
        #status.success { background: #163e21; color: #6bff6b; }
        .progress-container {
            margin-top: 20px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #16213e;
            border-radius: 12px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.2s;
        }
        .progress-text {
            margin-top: 8px;
            font-size: 13px;
            color: #888;
        }
        .error-box {
            background: #3e1621;
            color: #ff6b6b;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
        }
        #media-container {
            margin: 20px 0;
            display: none;
        }
        #media-container video {
            max-width: 80vw;
            max-height: calc(100vh - 300px);
            border-radius: 6px;
            background: #000;
        }
        #media-container audio {
            width: 100%;
            max-width: 500px;
        }
        details {
            margin-bottom: 20px;
            text-align: left;
            background: #16213e;
            border-radius: 6px;
            padding: 8px 16px;
            display: inline-block;
        }
        details summary {
            cursor: pointer;
            color: #888;
            font-size: 13px;
            text-align: center;
        }
        details[open] {
            display: block;
            width: 80vw;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            padding: 12px 16px;
        }
        details[open] summary {
            margin-bottom: 12px;
            text-align: left;
        }
        .info-row {
            font-size: 12px;
            color: #aaa;
            margin: 8px 0;
            word-break: break-all;
        }
        .info-label {
            color: #666;
        }
        .cmd-box {
            background: #0d1117;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin-top: 12px;
            font-family: monospace;
            font-size: 11px;
            color: #8b949e;
            word-break: break-all;
            cursor: pointer;
            position: relative;
        }
        .cmd-box:hover {
            border-color: #00d4ff;
        }
        .cmd-box::after {
            content: 'Click to copy';
            position: absolute;
            top: -8px;
            right: 8px;
            background: #16213e;
            padding: 0 6px;
            font-size: 10px;
            color: #666;
        }
        .cmd-box.copied::after {
            content: 'Copied!';
            color: #6bff6b;
        }
        .expiry-countdown {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <h1><a href="https://github.com/leijurv/gb" style="color: inherit; text-decoration: none;">GB File Share</a></h1>
    <div id="content">
        <div class="filename" id="filename">Loading...</div>
        <div class="meta" id="meta"></div>
        <div>
            <details id="more-info">
                <summary>More info</summary>
                <div id="info-content"></div>
            </details>
        </div>
        <button id="download">Download</button>
        <div id="status"></div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
            <div class="progress-text" id="progress-text">0%</div>
        </div>
        <div id="media-container"></div>
    </div>

    <script type="module">
    const $ = id => document.getElementById(id);

    function parseHash() {
        // Go's url.Values.Encode() converts spaces to "+", and URLSearchParams
        // handles this correctly (application/x-www-form-urlencoded decoding)
        return Object.fromEntries(new URLSearchParams(window.location.hash.slice(1)));
    }
    function parseShortUrl() {
        const url = new URL(window.location.href);
        // Split the pathname by "/" and filter out empty strings
        let key = url.pathname.substring(1);
        if (key.length === 0) {
            $('content').innerHTML = `<div class="error-box">Missing path or parameters</div>`;
            throw new Error('Missing path or parameters');
        }
        const hashIndex = key.indexOf('/');
        if (hashIndex !== -1) key = key.slice(0, hashIndex);
        return key
    }
    async function parseAndRequestShortURL() {
        const key = parseShortUrl();
        const response = await fetch(`/share-data/${key}.json`)
        if (!response.ok) {
            $('content').innerHTML = `<div class="error-box">Request failed with status ${response.status}</div>`;
            throw new Error(`Request failed with status ${response.status}`);
        }
        return await response.json()
    }

    const required = ['name', 'url', 'key', 'offset', 'length', 'size', 'sha256', 'cmp'];
    let params;
    let shortUrlKey = null; // If set, service worker will fetch fresh URLs on each request
    if (window.location.hash) {
        params = parseHash();
        const have = required.filter(k => k in params);
        if (have <= 1) {
            shortUrlKey = parseShortUrl();
            params = await parseAndRequestShortURL();
        }
    } else {
        shortUrlKey = parseShortUrl();
        params = await parseAndRequestShortURL();
    }

    const missing = required.filter(k => !(k in params));
    if (missing.length > 0) {
        $('content').innerHTML = `<div class="error-box">Missing parameters: ${missing.join(', ')}<br><br>This page expects a URL like:<br>share.html#name=...&url=...&key=...&offset=...&length=...&size=...&sha256=...&cmp=...</div>`;
        throw new Error('Missing params');
    }

    const filename = params.name;
    const s3Url = params.url;
    const keyHex = params.key.toLowerCase();
    const offset = parseInt(params.offset);
    const length = parseInt(params.length);
    const size = parseInt(params.size);
    const expectedSha256 = params.sha256;
    const compression = params.cmp;

    if (!/^[0-9a-f]{32}$/.test(keyHex)) {
        $('content').innerHTML = `<div class="error-box">Invalid encryption key: must be 32 hex characters</div>`;
        throw new Error('Invalid key');
    }
    if (compression !== "zstd" && compression !== "") {
        $('content').innerHTML = `<div class="error-box">Invalid compression: only zstd is supported</div>`;
        throw new Error('Invalid compression');
    }

    // Parse expiry from S3 presigned URL (X-Amz-Date + X-Amz-Expires)
    function parseS3Expiry(url) {
        try {
            const urlObj = new URL(url);
            const amzDate = urlObj.searchParams.get('X-Amz-Date'); // format: 20260102T090602Z
            const amzExpires = urlObj.searchParams.get('X-Amz-Expires'); // seconds
            if (amzDate && amzExpires) {
                const year = amzDate.slice(0, 4);
                const month = amzDate.slice(4, 6);
                const day = amzDate.slice(6, 8);
                const hour = amzDate.slice(9, 11);
                const min = amzDate.slice(11, 13);
                const sec = amzDate.slice(13, 15);
                const created = new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`);
                return created.getTime() + parseInt(amzExpires) * 1000;
            }
        } catch (e) {
        }
        return null;
    }

    const expiresAt = parseS3Expiry(s3Url);
    const isExpired = expiresAt && expiresAt < Date.now();

    $('filename').textContent = filename;
    $('meta').textContent = `${(size / 1024 / 1024).toFixed(2)} MB` + (compression === 'zstd' ? ` (${(length / 1024 / 1024).toFixed(2)} MB compressed)` : '');

    // Generate the curl command following paranoia/file.go
    function generateCurlCommand() {
        const alignedOffset = Math.floor(offset / 16) * 16;
        const remainingSeek = offset % 16;
        const fetchLength = length + remainingSeek;

        // Calculate IV (AES-CTR counter from block number)
        const blockNum = Math.floor(offset / 16);
        let iv = '';
        let n = blockNum;
        for (let i = 0; i < 16; i++) {
            iv = (n & 0xff).toString(16).padStart(2, '0') + iv;
            n = Math.floor(n / 256);
        }

        let cmd = `curl -H 'Range: bytes=${alignedOffset}-${alignedOffset + fetchLength - 1}' '${s3Url}' | `;
        cmd += `openssl enc -aes-128-ctr -d -K ${keyHex} -iv ${iv} 2>/dev/null | `;
        if (remainingSeek > 0) {
            cmd += `{ dd bs=${remainingSeek} skip=1 count=0 status=none; cat; } | `;
        }
        cmd += `head -c ${length}`;
        if (compression === 'zstd') {
            cmd += ` | zstd -d`;
        }
        cmd += ` > '${filename.replace(/'/g, "'\\''")}'`;
        return cmd;
    }

    // Convert base64url sha256 to hex for display
    function sha256ToHex(b64url) {
        const b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
        const padded = b64 + '=='.slice(0, (4 - b64.length % 4) % 4);
        const binary = atob(padded);
        return Array.from(binary, c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
    }

    // Format countdown
    function formatCountdown(ms) {
        if (ms <= 0) return 'EXPIRED';
        const hours = Math.floor(ms / 3600000);
        const mins = Math.floor((ms % 3600000) / 60000);
        const secs = Math.floor((ms % 60000) / 1000);
        if (hours > 24) {
            const days = Math.floor(hours / 24);
            return `${days}d ${hours % 24}h`;
        }
        if (hours > 0) return `${hours}h ${mins}m`;
        if (mins > 0) return `${mins}m ${secs}s`;
        return `${secs}s`;
    }

    // Populate info section
    const curlCmd = generateCurlCommand();
    const sha256Hex = sha256ToHex(expectedSha256);
    let infoHtml = `
        <div class="info-row"><span class="info-label">Shared with:</span> <a href="https://github.com/leijurv/gb" style="color: #00d4ff;">gb</a></div>
        <div class="info-row"><span class="info-label">File size:</span> ${size.toLocaleString()} bytes${compression === 'zstd' ? ` (${length.toLocaleString()} bytes compressed)` : ''}</div>
        <div class="info-row"><span class="info-label">SHA-256:</span> ${sha256Hex}</div>
        <div class="info-row"><span class="info-label">Compression:</span> ${compression || 'none'}</div>
        ${expiresAt ? `<div class="info-row"><span class="info-label">URL expires in:</span> <span class="expiry-countdown" id="expiry-countdown">${formatCountdown(expiresAt - Date.now())}</span></div>` : ''}
        <div class="info-row"><span class="info-label">Manual download command:</span></div>
        <div class="cmd-box" id="cmd-box">${curlCmd.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
    `;
    $('info-content').innerHTML = infoHtml;

    // Click to copy
    $('cmd-box').addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(curlCmd);
            $('cmd-box').classList.add('copied');
            setTimeout(() => $('cmd-box').classList.remove('copied'), 2000);
        } catch (e) {
            console.error('Copy failed:', e);
        }
    });

    // Update countdown every second (only meaningful for static hash URLs)
    if (expiresAt && !shortUrlKey) {
        setInterval(() => {
            const remaining = expiresAt - Date.now();
            $('expiry-countdown').textContent = formatCountdown(remaining);
            if (remaining <= 0) {
                $('expiry-countdown').style.fontWeight = 'bold';
                $('download').disabled = true;
                showStatus('This share link has expired. Ask the sender for a new link.', 'error');
            }
        }, 1000);
    }

    const downloadUrl = '/gb/webshare/gb-download?id=' + encodeURIComponent(expectedSha256);

    function sendParamsToServiceWorker() {
        navigator.serviceWorker.controller?.postMessage({
            type: 'download',
            params: {
                url: s3Url,
                key: keyHex,
                offset: offset,
                length: length,
                size: size,
                sha256: expectedSha256,
                compression: compression,
                filename: filename,
                shortUrlKey: shortUrlKey // If set, SW fetches fresh presigned URL on each request
            }
        });
    }

    function waitForServiceWorkerReady() {
        return new Promise((resolve) => {
            const handler = (event) => {
                if (event.data.type === 'pong') {
                    navigator.serviceWorker.removeEventListener('message', handler);
                    resolve();
                }
            };
            navigator.serviceWorker.addEventListener('message', handler);
            navigator.serviceWorker.controller?.postMessage({type: 'ping'});
        });
    }

    const ext = filename.split('.').pop().toLowerCase();
    const isVideo = ['mp4', 'webm', 'mov', 'mkv', 'avi'].includes(ext);
    const isAudio = ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac'].includes(ext);
    const isImage = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico'].includes(ext);
    const isPdf = ext === 'pdf';

    const mediaUrl = downloadUrl + '&media=true';

    function showMediaPlayer() {
        if (isVideo) {
            const video = document.createElement('video');
            video.controls = true;
            video.preload = 'metadata';
            video.src = mediaUrl;
            $('media-container').appendChild(video);
            $('media-container').style.display = 'block';
        } else if (isAudio) {
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.preload = 'metadata';
            audio.src = mediaUrl;
            $('media-container').appendChild(audio);
            $('media-container').style.display = 'block';
        } else if (isImage) {
            const img = document.createElement('img');
            img.src = mediaUrl;
            img.alt = filename;
            img.style.maxWidth = '80vw';
            img.style.maxHeight = 'calc(100vh - 300px)';
            img.style.borderRadius = '6px';
            $('media-container').appendChild(img);
            $('media-container').style.display = 'block';
        } else if (isPdf) {
            const iframe = document.createElement('iframe');
            iframe.src = mediaUrl;
            iframe.style.width = '80vw';
            iframe.style.height = 'calc(100vh - 300px)';
            iframe.style.border = 'none';
            iframe.style.borderRadius = '6px';
            $('media-container').appendChild(iframe);
            $('media-container').style.display = 'block';
        }
    }

    function showStatus(msg, type = '') {
        const status = $('status');
        status.style.display = 'block';
        status.className = type;
        status.textContent = msg;
    }

    async function registerServiceWorker() {
        if (!('serviceWorker' in navigator)) {
            throw new Error('Service Workers not supported');
        }

        const registration = await navigator.serviceWorker.register('/gb/webshare/share-sw.js', { scope: '/' });

        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', function () {
                    if (this.state === 'activated') resolve();
                });
            });
        }

        if (!navigator.serviceWorker.controller) {
            // Wait for controllerchange, with timeout for hard reload edge case
            await Promise.race([
                new Promise(resolve => {
                    navigator.serviceWorker.addEventListener('controllerchange', resolve, {once: true});
                }),
                new Promise(resolve => setTimeout(resolve, 1000))
            ]);

            // If still no controller (hard reload), do a soft reload to let SW take control
            if (!navigator.serviceWorker.controller) {
                window.location.reload();
                return;
            }
        }

        return registration;
    }

    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
        return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
    }

    function handleServiceWorkerMessage(event) {
        const data = event.data;
        if (data.id !== expectedSha256) return; // ignore messages for other downloads

        if (data.type === 'progress') {
            // If we see progress, ensure UI reflects download in progress
            $('download').disabled = true;
            $('progress-container').style.display = 'block';
            $('status').style.display = 'block';
            $('status').className = '';
            $('status').textContent = 'Downloading... (check your browser\'s downloads)';

            const pct = Math.min(100, (data.bytes / size) * 100);
            $('progress-fill').style.width = pct + '%';
            $('progress-text').textContent = `${formatBytes(data.bytes)} / ${formatBytes(size)} (${pct.toFixed(1)}%)`;
        } else if (data.type === 'complete') {
            $('progress-fill').style.width = '100%';
            if (data.sha256 === expectedSha256) {
                $('progress-container').style.display = 'none';
                showStatus('Download completed and verified âœ“\n(check your browser\'s downloads)', 'success');
            } else {
                showStatus('INTEGRITY CHECK FAILED - file may be corrupted!', 'error');
                alert('INTEGRITY CHECK FAILED!\n\nExpected: ' + expectedSha256 + '\nGot: ' + data.sha256 + '\n\nThe downloaded file may be corrupted or tampered with.');
            }
        } else if (data.type === 'error') {
            showStatus('Error: ' + data.message, 'error');
            $('progress-container').style.display = 'none';
            $('download').disabled = false;
        }
    }

    // Start listening immediately to detect in-progress downloads
    navigator.serviceWorker?.addEventListener('message', handleServiceWorkerMessage);

    async function downloadFile() {
        $('download').disabled = true;
        showStatus('Making request to download...', '');

        try {
            await registerServiceWorker();
            await waitForServiceWorkerReady();
            sendParamsToServiceWorker();

            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = downloadUrl;
            document.body.appendChild(iframe);

            setTimeout(() => iframe.remove(), 5000);

        } catch (e) {
            showStatus('Error: ' + e.message, 'error');
            $('progress-container').style.display = 'none';
            console.error(e);
            $('download').disabled = false;
        }
    }

    $('download').addEventListener('click', downloadFile);

    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        showStatus('Error: HTTPS required for Service Workers', 'error');
        $('download').disabled = true;
    } else if (isExpired && !shortUrlKey) {
        // Only block on expiry for static hash URLs; short URL mode fetches fresh URLs
        showStatus('This share link has expired. Ask the sender for a new link.', 'error');
        $('download').disabled = true;
    }

    // Initialize service worker on page load so media can stream immediately
    // In short URL mode, always initialize since fresh URLs are fetched per request
    if (!isExpired || shortUrlKey) {
        (async () => {
            try {
                await registerServiceWorker();
                await waitForServiceWorkerReady();
                sendParamsToServiceWorker();
                showMediaPlayer();
            } catch (e) {
                console.error('Failed to initialize service worker:', e);
            }
        })();
    }
    </script>
</body>
</html>
