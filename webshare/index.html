<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=">
    <title>GB File Download</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            text-align: center;
        }
        h1 { color: #00d4ff; margin-bottom: 10px; font-size: 20px; }
        .filename {
            font-size: 24px;
            margin: 20px 0;
            word-break: break-all;
            color: #fff;
        }
        .meta {
            color: #888;
            font-size: 13px;
            margin-bottom: 20px;
        }
        button {
            padding: 18px 50px;
            border: none;
            border-radius: 6px;
            background: #00d4ff;
            color: #1a1a2e;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #00b8e6; }
        button:disabled { background: #555; cursor: not-allowed; }
        #status {
            margin-top: 25px;
            padding: 15px;
            border-radius: 4px;
            background: #16213e;
            font-size: 14px;
            display: none;
        }
        #status.error { background: #3e1621; color: #ff6b6b; }
        #status.success { background: #163e21; color: #6bff6b; }
        .progress-container {
            margin-top: 20px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #16213e;
            border-radius: 12px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.2s;
        }
        .progress-text {
            margin-top: 8px;
            font-size: 13px;
            color: #888;
        }
        .error-box {
            background: #3e1621;
            color: #ff6b6b;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
        }
        #zip-container {
            margin: 20px auto;
            display: none;
            background-color: #121221;
            border: 1px solid #3a5287;
            border-radius: 5px;
            padding: 10px;
        }
        #zip-container li {
            list-style: none;
        }
        .media-container {
            margin: 20px auto;
            display: none;
        }
        .media-container video {
            max-width: 80vw;
            max-height: calc(100vh - 300px);
            border-radius: 6px;
            background: #000;
        }
        .media-container audio {
            width: 100%;
            max-width: 500px;
        }
        details {
            margin-bottom: 20px;
            text-align: left;
            background: #16213e;
            border-radius: 6px;
            padding: 8px 16px;
            display: inline-block;
        }
        details summary {
            cursor: pointer;
            color: #888;
            font-size: 13px;
            text-align: center;
        }
        details[open] {
            display: block;
            width: 80vw;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            padding: 12px 16px;
        }
        details[open] summary {
            margin-bottom: 12px;
            text-align: left;
        }
        .info-row {
            font-size: 12px;
            color: #aaa;
            margin: 8px 0;
            word-break: break-all;
        }
        .info-label {
            color: #666;
        }
        .cmd-box {
            background: #0d1117;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin-top: 12px;
            font-family: monospace;
            font-size: 11px;
            color: #8b949e;
            word-break: break-all;
            cursor: pointer;
            position: relative;
        }
        .cmd-box:hover {
            border-color: #00d4ff;
        }
        .cmd-box::after {
            content: 'Click to copy';
            position: absolute;
            top: -8px;
            right: 8px;
            background: #16213e;
            padding: 0 6px;
            font-size: 10px;
            color: #666;
        }
        .cmd-box.copied::after {
            content: 'Copied!';
            color: #6bff6b;
        }
        .expiry-countdown {
            color: #ff6b6b;
        }
        .img-wrapper {
            display: inline-grid;
            place-items: center;
        }
        .img-wrapper > * {
            grid-area: 1 / 1;
        }
    </style>
</head>
<body>
    <h1><a href="https://github.com/leijurv/gb" style="color: inherit; text-decoration: none;">GB File Share</a></h1>
    <div id="content">
        <div class="filename" id="filename">Loading...</div>
        <div class="meta" id="meta"></div>
        <div>
            <details id="more-info">
                <summary>More info</summary>
                <div id="info-content"></div>
            </details>
        </div>
        <button id="download">Download</button>
        <div id="status"></div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
            <div class="progress-text" id="progress-text">0%</div>
        </div>
        <div id="zip-container"></div>
        <div id="media-container" class="media-container"></div>
    </div>

    <script type="module">
    // If we're being loaded as the /gb-download URL (SW didn't intercept), bail out
    if (location.pathname.startsWith('/gb/webshare/gb-download')) {
        console.error('ERROR: gb-download request was not intercepted by service worker');
        document.body.innerHTML = '<pre style="color: red;">Error: Service worker not active.\nThis request should have been intercepted by the service worker.\nTry reloading the page.</pre>';
        throw new Error('SW not intercepting');
    }

    // Receive SW logs via BroadcastChannel (for Firefox debugging)
    const swLogChannel = new BroadcastChannel('sw-logs');
    swLogChannel.onmessage = (e) => console.log('[SW→Page]', e.data);

    // Auto-reload for cross-origin isolation (needed for SharedArrayBuffer/multi-threading)
    // On first visit, SW isn't active yet so page loads without COOP/COEP headers.
    // Once SW is ready, reload to get the headers.
    {
        const COI_FLAG = 'coi-reload-attempted';

        if (crossOriginIsolated) {
            // Already isolated - clear flag so future SW changes can trigger reload
            sessionStorage.removeItem(COI_FLAG);
        } else if (!navigator.serviceWorker?.controller) {
            // No SW controller (first visit, force reload, or SW unregistered) - clear flag
            sessionStorage.removeItem(COI_FLAG);
        }

        // If not isolated and haven't attempted reload this session, try once SW is ready
        if (!crossOriginIsolated && !sessionStorage.getItem(COI_FLAG)) {
            navigator.serviceWorker?.ready.then(() => {
                // Double-check we're still not isolated (ready event might fire late)
                if (!crossOriginIsolated) {
                    console.log('[COI] Reloading to enable cross-origin isolation for multi-threading');
                    sessionStorage.setItem(COI_FLAG, '1');
                    window.location.reload();
                }
            });
        }
    }

    async function readStreamWithLimitButItMustBeTextOrIReturnNull(reader, maxBytes) {
        const chunks = [];
        let bytesRead = 0;
        let truncated = false;
        while (bytesRead < maxBytes) {
            const { done, value } = await reader.read();
            if (done) break;

            const bytesToTake = Math.min(value.length, maxBytes - bytesRead);
            if (bytesToTake < value.length) {
                truncated = true;
                // Only take part of this chunk
                let slice = value.slice(0, bytesToTake);
                if (slice.includes(0)) {
                    await reader.cancel();
                    return [null, false];
                }
                chunks.push(slice);
                bytesRead += bytesToTake;
                break;
            } else {
                if (value.includes(0)) {
                    await reader.cancel();
                    return [null, false];
                }
                chunks.push(value);
                bytesRead += value.length;
            }
        }

        await reader.cancel();

        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const combined = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
        }

        return [combined.buffer, truncated];
    }

    const $ = id => document.getElementById(id);

    function showErrorBox(...parts) {
        // parts can be strings or {br: true} for line breaks
        const content = $('content');
        content.innerHTML = '';
        const errorBox = document.createElement('div');
        errorBox.className = 'error-box';
        for (const part of parts) {
            if (part && part.br) {
                errorBox.appendChild(document.createElement('br'));
            } else {
                errorBox.appendChild(document.createTextNode(part));
            }
        }
        content.appendChild(errorBox);
    }

    function parseHash() {
        // Go's url.Values.Encode() converts spaces to "+", and URLSearchParams
        // handles this correctly (application/x-www-form-urlencoded decoding)
        return Object.fromEntries(new URLSearchParams(window.location.hash.slice(1)));
    }
    function parseShortUrl() {
        const url = new URL(window.location.href);
        // Split the pathname by "/" and filter out empty strings
        let key = url.pathname.substring(1);
        if (key.length === 0) {
            showErrorBox('Missing path or parameters');
            throw new Error('Missing path or parameters');
        }
        const hashIndex = key.indexOf('/');
        if (hashIndex !== -1) key = key.slice(0, hashIndex);
        return key
    }
    // Parse file index from shortUrlKey (e.g., "password-5" -> {baseKey: "password", fileIndex: 5})
    function parseFileIndex(key) {
        const match = key.match(/^(.+)-(\d+)$/);
        if (match) {
            return { baseKey: match[1], fileIndex: parseInt(match[2]) };
        }
        return { baseKey: key, fileIndex: null };
    }
    function formatExpiredTime(unixSeconds) {
        const date = new Date(unixSeconds * 1000);
        return date.toLocaleString();
    }

    function showExpiredError(expiresAtUnix) {
        const expiredTime = formatExpiredTime(expiresAtUnix);
        showErrorBox('This share link has expired.', {br:true}, {br:true}, 'Expired at: ', expiredTime, {br:true}, {br:true}, 'Ask the sender for a new link.');
    }

    // Lepton worker for multi-threaded JPEG decompression (SW can't spawn workers)
    // Initialize immediately to overlap WASM/thread pool setup with .lep download
    let leptonWorker = null;
    let leptonWorkerReady = null;

    function initLeptonWorker() {
        if (leptonWorkerReady) return leptonWorkerReady;

        leptonWorkerReady = new Promise((resolve, reject) => {
            // Use path relative to current location (works on both GitHub Pages and CF Workers)
            const leptonWorkerUrl = new URL('lepton/lepton-worker.js', location.href);
            // Allow thread count override via ?lepton_threads=N for debugging
            const threadOverride = new URLSearchParams(location.search).get('lepton_threads');
            if (threadOverride) {
                leptonWorkerUrl.searchParams.set('threads', threadOverride);
            }
            leptonWorker = new Worker(leptonWorkerUrl.href, { type: 'module' });

            leptonWorker.onerror = (e) => {
                console.error('[Page] Lepton worker error:', e);
                reject(e);
            };

            // Wait for worker to signal it's ready (after WASM + thread pool init)
            leptonWorker.onmessage = (e) => {
                if (e.data.type === 'ready') {
                    resolve();
                }
            };
        });

        return leptonWorkerReady;
    }

    // Store share metadata for SW communication
    let shareMetadata = null;

    // Ask SW to fetch and decrypt share data
    async function fetchShareFromSW(password) {
        await registerServiceWorker();
        const reg = await navigator.serviceWorker.ready;
        const { port1, port2 } = new MessageChannel();
        return new Promise((resolve, reject) => {
            port1.onmessage = (event) => {
                if (event.data.error) {
                    reject(new Error(event.data.error));
                } else {
                    resolve(event.data);
                }
            };
            reg.active.postMessage({ type: 'fetch-share', password }, [port2]);
        });
    }

    // Returns { entries, fileIndex } where fileIndex is set if URL had -N suffix
    async function parseAndRequestShortURL() {
        const key = parseShortUrl();
        // Check for -N suffix (individual file from folder)
        const { baseKey, fileIndex } = parseFileIndex(key);

        // Ask SW to fetch and decrypt the share data
        let data;
        try {
            data = await fetchShareFromSW(baseKey);
        } catch (e) {
            // Handle specific error messages from SW
            if (e.message.includes('expired')) {
                showExpiredError(Math.floor(Date.now() / 1000));
                throw new Error('Share link expired');
            }
            if (e.message.includes('revoked')) {
                showErrorBox('This share has been revoked');
                throw new Error('This share has been revoked');
            }
            if (e.message.includes('not found')) {
                showErrorBox('Share not found');
                throw new Error('Share not found');
            }
            showErrorBox('Error: ', e.message);
            throw e;
        }

        const { entries, nonce, byteOffsets } = data;

        // Store metadata for SW communication (keyed by baseKey for -N suffix support)
        shareMetadata = {
            nonce,
            byteOffsets,
            baseKey
        };

        return { entries, fileIndex, baseKey };
    }

    function parseZipFileName() {
        const url = new URL(window.location.href);
        const pathSegments = url.pathname.split('/').filter(segment => segment !== '');
        if (pathSegments[1]) {
            return pathSegments[1].endsWith('.zip') ? pathSegments[1] : pathSegments[1] + '.zip'
        }
        return 'download.zip'
    }
    // TODO: use client-zip to compute actual length
    function estimateZipSize(array) {
        let size = 0;
        for (let p of array) {
            size += p.size;
        }
        return size;
    }

    function showMediaPlayer(filename, mediaUrl, embedError, elementId) {
        const ext = filename.split('.').pop().toLowerCase();
        const isVideo = ['mp4', 'webm', 'mov', 'mkv', 'avi'].includes(ext);
        const isAudio = ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac'].includes(ext);
        const isImage = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico'].includes(ext);
        const isPdf = ext === 'pdf';

        //const elemId = `media-container-${containerId}`;
        // IMPORTANT: Always set src AFTER appendChild - Firefox doesn't route
        // requests through SW for elements not yet in the DOM
        if (isVideo) {
            const video = document.createElement('video');
            video.controls = true;
            video.preload = 'metadata';
            // do we actually want this?
            video.onerror = () => location.reload();  // SW may have been terminated
            $(elementId).appendChild(video);
            video.src = mediaUrl;  // src AFTER appendChild
            $(elementId).style.display = 'block';
        } else if (isAudio) {
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.preload = 'metadata';
            audio.style = 'width: 100%;';
            $(elementId).appendChild(audio);
            audio.src = mediaUrl;  // src AFTER appendChild
            $(elementId).style.display = 'block';
        } else if (isImage) {
            const wrapper = document.createElement('div');
            wrapper.className = 'img-wrapper';
            wrapper.innerHTML = `<style spin>@keyframes spin { to { transform: rotate(360deg); } } [spin] { display: block; font:0 x; width:33Q; height:33Q; border-radius: 33Q; border: 4px solid grey; border-top-color: blue; animation: spin linear 1s infinite }</style>`;
            const spinner = wrapper.querySelector('[spin]');
            const img = document.createElement('img');
            img.alt = filename;
            img.style.maxWidth = '80vw';
            img.style.maxHeight = 'calc(100vh - 300px)';
            img.style.borderRadius = '6px';
            img.onload = () => spinner.remove();
            wrapper.appendChild(img);
            $(elementId).appendChild(wrapper);
            img.src = mediaUrl;  // src AFTER appendChild
            $(elementId).style.display = 'block';
        } else if (isPdf) {
            const iframe = document.createElement('iframe');
            iframe.style.width = '80vw';
            iframe.style.height = 'calc(100vh - 300px)';
            iframe.style.border = 'none';
            iframe.style.borderRadius = '6px';
            $(elementId).appendChild(iframe);
            iframe.src = mediaUrl;  // src AFTER appendChild
            $(elementId).style.display = 'block';
        } else {
            (async () => {
                try {
                    const response = await fetch(mediaUrl);
                    if (!response.ok) {
                        console.log('preview fetch failed');
                        return;
                    }
                    const reader = response.body.getReader();
                    const [buffer, truncated] = await readStreamWithLimitButItMustBeTextOrIReturnNull(reader, 10_000_000);
                    // Cancel the reader to stop downloading more
                    if (buffer !== null) {
                        if (truncated) {
                            const warning = document.createElement('div');
                            warning.textContent = '⚠️ Preview truncated to 10MB';
                            warning.style.color = '#b45309';            // dark orange
                            warning.style.backgroundColor = '#fff7ed';  // light orange
                            warning.style.border = '1px solid #f59e0b';
                            warning.style.padding = '8px 12px';
                            warning.style.marginBottom = '8px';
                            warning.style.fontFamily = 'sans-serif';
                            warning.style.fontSize = '0.9em';

                            $(elementId).appendChild(warning);
                        }

                        const container = document.createElement('div');
                        container.style.width = '80vw';
                        container.style.maxHeight = 'calc(100vh - 300px)';
                        container.style.overflow = 'auto';
                        // same look as the zip container
                        container.style.backgroundColor = '#121221';
                        container.style.border = "1px solid #3a5287";
                        container.style.borderRadius = '5px';
                        container.style.padding = '12px';
                        //container.style.backgroundColor = 'transparent';
                        container.style.fontFamily = 'monospace';
                        container.style.whiteSpace = 'pre-wrap';
                        container.style.wordBreak = 'break-word';
                        container.style.textAlign = 'left';
                        container.textContent = new TextDecoder('utf-8').decode(buffer);

                        $(elementId).appendChild(container);
                        $(elementId).style.display = 'table';
                    } else if (embedError) {
                        const error = document.createElement('div');
                        error.style.padding = '12px';
                        error.style.color = '#d32f2f';
                        error.textContent = 'This file is not text';

                        $(elementId).appendChild(error);
                        $(elementId).style.display = 'table';
                    }
                } catch (error) {
                    console.error('Failed to fetch and display file:', error);
                }
            })();
        }
    }

    const required = ['name', 'url', 'key', 'offset', 'length', 'size', 'sha256', 'cmp'];
    let params;
    let allParams = null; // All entries for SW communication (even when displaying single file)
    let shortUrlKey = null; // If set, service worker will fetch fresh URLs on each request
    let fileIndexFromFolder = null; // If URL had -N suffix, this is the file index
    let folderBaseKey = null; // The base key without -N suffix
    if (window.location.hash) {
        // Hash mode: raw params need transformation
        let rawParams = parseHash();
        const missing = required.filter(k => !(k in rawParams));
        if (missing.length > 0) {
            showErrorBox('Missing parameters: ', missing.join(', '), {br:true}, {br:true}, 'This page expects a URL like:', {br:true}, 'share.html#name=...&url=...&key=...&offset=...&length=...&size=...&sha256=...&cmp=...');
            throw new Error('Missing params');
        }
        // Transform raw params to normalized format
        params = [{
            compression: rawParams.cmp,
            key: rawParams.key.toLowerCase(),
            length: parseInt(rawParams.length),
            offset: parseInt(rawParams.offset),
            size: parseInt(rawParams.size),
            name: rawParams.name,
            filename: rawParams.name,
            path: rawParams.path,
            sha256: rawParams.sha256,
            url: rawParams.url
        }];
    } else {
        // Short URL mode: SW already returns normalized params
        const result = await parseAndRequestShortURL();
        params = result.entries;
        fileIndexFromFolder = result.fileIndex;
        folderBaseKey = result.baseKey;
        // Use baseKey for SW communication (works for both /password and /password-N URLs)
        shortUrlKey = folderBaseKey;
    }

    // If URL had -N suffix, filter to just that entry for display
    // But keep all entries for SW communication
    if (fileIndexFromFolder !== null) {
        if (fileIndexFromFolder < 0 || fileIndexFromFolder >= params.length) {
            showErrorBox(`File index ${fileIndexFromFolder} out of range (0-${params.length - 1})`);
            throw new Error('File index out of range');
        }
        allParams = params; // Keep all for SW (already transformed)
        params = [params[fileIndexFromFolder]]; // Filter for display
    }

    // Message ID for SW communication: shortUrlKey in short URL mode, sha256 in hash mode
    // This allows error/progress messages to be displayed in both modes
    const messageId = shortUrlKey || (params.length === 1 ? params[0].sha256 : null);

    // variables assigned by single file and zip mode
    let isExpired = false;
    let downloadUrl;

    if (params.length > 1) {
        const zipFileName = parseZipFileName();
        $('filename').textContent = zipFileName;
        $('meta').innerText = `${(estimateZipSize(params) / 1024 / 1024).toFixed(2)} MB \n ${params.length} files`;
        $('more-info').remove();
        downloadUrl = `/gb/webshare/gb-download?password=${shortUrlKey}&download-filename=${parseZipFileName()}`;

        $('zip-container').style.display = 'table';

        function toggleDropdown(btn, dropdown, mediaContainer, filename, sha256, password) {
            if (dropdown.style.display === 'none') {
                dropdown.style.display = 'block';
                btn.textContent = '▲';
                const mediaUrl = `/gb/webshare/gb-download?password=${encodeURIComponent(password)}&hash=${sha256}&media=true`;
                showMediaPlayer(filename, mediaUrl, true, mediaContainer);
            } else {
                dropdown.style.display = 'none';
                btn.textContent = '▼';
                $(mediaContainer).innerHTML = '';
            }
        }

        const zipContainer = $('zip-container');
        params.forEach((p, i) => {
            const li = document.createElement('li');
            li.style.cssText = 'list-style: none; margin-bottom: 5px;';

            const rowDiv = document.createElement('div');
            rowDiv.style.cssText = 'display: flex; align-items: center; gap: 10px;';

            const btn = document.createElement('button');
            btn.id = `dropdown-btn-${i}`;
            btn.style.cssText = 'cursor: pointer; padding: 2px 8px;';
            btn.textContent = '▼';

            const link = document.createElement('a');
            link.href = `/${encodeURIComponent(shortUrlKey)}-${i}/${encodeURIComponent(zipFileName)}`;
            link.style.color = '#00d4ff';
            link.textContent = p.filename;

            const sizeSpan = document.createElement('span');
            sizeSpan.textContent = `(${formatBytes(p.size)})`;

            rowDiv.appendChild(btn);
            rowDiv.appendChild(link);
            rowDiv.appendChild(sizeSpan);

            const dropdown = document.createElement('div');
            dropdown.id = `dropdown-${i}`;
            dropdown.style.cssText = 'display: none; margin-top: 5px; padding: 10px;';

            const mediaContainer = document.createElement('div');
            mediaContainer.id = `media-container-${i}`;
            mediaContainer.className = 'media-container';
            dropdown.appendChild(mediaContainer);

            btn.addEventListener('click', () => {
                toggleDropdown(btn, dropdown, mediaContainer.id, p.filename, p.sha256, p.shortUrlKey);
            });

            li.appendChild(rowDiv);
            li.appendChild(dropdown);
            zipContainer.appendChild(li);
        });

    } else {
        $('media-container').style.display = 'table';

        const filename = params[0].name;
        const s3Url = params[0].url;
        const keyHex = params[0].key;
        const offset = params[0].offset;
        const length = params[0].length;
        const size = params[0].size;
        const compression = params[0].compression;

        if (!/^[0-9a-f]{32}$/.test(keyHex)) {
            showErrorBox('Invalid encryption key: must be 32 hex characters');
            throw new Error('Invalid key');
        }
        if (compression !== "zstd" && compression !== "lepton" && compression !== "") {
            showErrorBox('Invalid compression: only zstd and lepton are supported');
            throw new Error('Invalid compression');
        }

        // Parse expiry from S3 presigned URL (X-Amz-Date + X-Amz-Expires)
        function parseS3Expiry(url) {
            try {
                const urlObj = new URL(url);
                const amzDate = urlObj.searchParams.get('X-Amz-Date'); // format: 20260102T090602Z
                const amzExpires = urlObj.searchParams.get('X-Amz-Expires'); // seconds
                if (amzDate && amzExpires) {
                    const year = amzDate.slice(0, 4);
                    const month = amzDate.slice(4, 6);
                    const day = amzDate.slice(6, 8);
                    const hour = amzDate.slice(9, 11);
                    const min = amzDate.slice(11, 13);
                    const sec = amzDate.slice(13, 15);
                    const created = new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`);
                    return created.getTime() + parseInt(amzExpires) * 1000;
                }
            } catch (e) {
            }
            return null;
        }

        const expiresAt = parseS3Expiry(s3Url);
        isExpired = expiresAt && expiresAt < Date.now();

        $('filename').textContent = filename;
        $('meta').innerHTML = `${(size / 1024 / 1024).toFixed(2)} MB` + (compression ? ` (${(length / 1024 / 1024).toFixed(2)} MB compressed)` : '');

        // Show folder reference if this is an individual file from a folder
        if (fileIndexFromFolder !== null) {
            const folderUrl = `/${encodeURIComponent(folderBaseKey)}/${encodeURIComponent(parseZipFileName())}`;
            const br = document.createElement('br');
            const span = document.createElement('span');
            span.style.color = '#fff';
            span.appendChild(document.createTextNode(`This is file ${fileIndexFromFolder + 1} from a `));
            const folderLink = document.createElement('a');
            folderLink.href = folderUrl;
            folderLink.style.color = '#00d4ff';
            folderLink.textContent = 'shared folder';
            span.appendChild(folderLink);
            $('meta').appendChild(br);
            $('meta').appendChild(span);
        }

        // Generate the curl command following paranoia/file.go
        function generateCurlCommand() {
            const alignedOffset = Math.floor(offset / 16) * 16;
            const remainingSeek = offset % 16;
            const fetchLength = length + remainingSeek;

            // Calculate IV (AES-CTR counter from block number)
            const blockNum = Math.floor(offset / 16);
            let iv = '';
            let n = blockNum;
            for (let i = 0; i < 16; i++) {
                iv = (n & 0xff).toString(16).padStart(2, '0') + iv;
                n = Math.floor(n / 256);
            }

            let cmd = `curl -H 'Range: bytes=${alignedOffset}-${alignedOffset + fetchLength - 1}' '${s3Url}' | `;
            cmd += `openssl enc -aes-128-ctr -d -K ${keyHex} -iv ${iv} 2>/dev/null | `;
            if (remainingSeek > 0) {
                cmd += `{ dd bs=${remainingSeek} skip=1 count=0 status=none; cat; } | `;
            }
            cmd += `head -c ${length}`;
            if (compression === 'zstd') {
                cmd += ` | zstd -d`;
            } else if (compression === 'lepton') {
                cmd += ` | lepton -`;  // lepton reads from stdin, writes to stdout
            }
            cmd += ` > '${filename.replace(/'/g, "'\\''")}'`;
            return cmd;
        }

        // Convert base64url sha256 to hex for display
        function sha256ToHex(b64url) {
            const b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
            const padded = b64 + '=='.slice(0, (4 - b64.length % 4) % 4);
            const binary = atob(padded);
            return Array.from(binary, c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
        }

        // Format countdown
        function formatCountdown(ms) {
            if (ms <= 0) return 'EXPIRED';
            const hours = Math.floor(ms / 3600000);
            const mins = Math.floor((ms % 3600000) / 60000);
            const secs = Math.floor((ms % 60000) / 1000);
            if (hours > 24) {
                const days = Math.floor(hours / 24);
                return `${days}d ${hours % 24}h`;
            }
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Populate info section
        const curlCmd = generateCurlCommand();
        const sha256Hex = sha256ToHex(params[0].sha256);
        const infoContent = $('info-content');

        function createInfoRow(label, value) {
            const row = document.createElement('div');
            row.className = 'info-row';
            const labelSpan = document.createElement('span');
            labelSpan.className = 'info-label';
            labelSpan.textContent = label;
            row.appendChild(labelSpan);
            row.appendChild(document.createTextNode(' ' + value));
            return row;
        }

        // Shared with row (with link)
        const sharedRow = document.createElement('div');
        sharedRow.className = 'info-row';
        const sharedLabel = document.createElement('span');
        sharedLabel.className = 'info-label';
        sharedLabel.textContent = 'Shared with:';
        const gbLink = document.createElement('a');
        gbLink.href = 'https://github.com/leijurv/gb';
        gbLink.style.color = '#00d4ff';
        gbLink.textContent = 'gb';
        sharedRow.appendChild(sharedLabel);
        sharedRow.appendChild(document.createTextNode(' '));
        sharedRow.appendChild(gbLink);
        infoContent.appendChild(sharedRow);

        infoContent.appendChild(createInfoRow('File size:', `${size.toLocaleString()} bytes${compression ? ` (${length.toLocaleString()} bytes compressed)` : ''}`));
        infoContent.appendChild(createInfoRow('SHA-256:', sha256Hex));
        infoContent.appendChild(createInfoRow('Compression:', compression || 'none'));

        if (expiresAt) {
            const expiryRow = document.createElement('div');
            expiryRow.className = 'info-row';
            const expiryLabel = document.createElement('span');
            expiryLabel.className = 'info-label';
            expiryLabel.textContent = 'URL expires in:';
            const expiryValue = document.createElement('span');
            expiryValue.className = 'expiry-countdown';
            expiryValue.id = 'expiry-countdown';
            expiryValue.textContent = formatCountdown(expiresAt - Date.now());
            expiryRow.appendChild(expiryLabel);
            expiryRow.appendChild(document.createTextNode(' '));
            expiryRow.appendChild(expiryValue);
            infoContent.appendChild(expiryRow);
        }

        infoContent.appendChild(createInfoRow('Manual download command:', ''));

        const cmdBox = document.createElement('div');
        cmdBox.className = 'cmd-box';
        cmdBox.id = 'cmd-box';
        cmdBox.textContent = curlCmd;
        infoContent.appendChild(cmdBox);

        // Click to copy
        cmdBox.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(curlCmd);
                cmdBox.classList.add('copied');
                setTimeout(() => cmdBox.classList.remove('copied'), 2000);
            } catch (e) {
                console.error('Copy failed:', e);
            }
        });

        // Update countdown every second (only meaningful for static hash URLs)
        if (expiresAt && !shortUrlKey) {
            setInterval(() => {
                const remaining = expiresAt - Date.now();
                $('expiry-countdown').textContent = formatCountdown(remaining);
                if (remaining <= 0) {
                    $('expiry-countdown').style.fontWeight = 'bold';
                    $('download').disabled = true;
                    showStatus(`This share link has expired at ${formatExpiredTime(Math.floor(expiresAt / 1000))}. Ask the sender for a new link.`, 'error');
                }
            }, 1000);
        }

        if (shortUrlKey) {
            const paswordParam = `&password=${encodeURIComponent(shortUrlKey)}`;
            downloadUrl = `/gb/webshare/gb-download?hash=${encodeURIComponent(params[0].sha256)}${paswordParam}`;
        } else {
            downloadUrl = `/gb/webshare/gb-download?${window.location.hash.slice(1)}`
        }
    }

    // Wait for SW to actually be intercepting fetches (not just controlling)
    async function waitForSwIntercepting() {
        for (let i = 0; i < 50; i++) {  // max 5 seconds
            try {
                const resp = await fetch('/gb-sw-ping');
                if (await resp.text() === 'pong') return;
            } catch (e) {}
            await new Promise(r => setTimeout(r, 100));
        }
        throw new Error('SW never started intercepting fetches');
    }

    function showStatus(msg, type = '') {
        const status = $('status');
        status.style.display = 'block';
        status.className = type;
        status.textContent = msg;
    }

    async function registerServiceWorker() {
        if (!('serviceWorker' in navigator)) {
            throw new Error('Service Workers not supported');
        }

        const swUrl = '/gb/webshare/share-sw.js'; // <-- note vite.config.js will edit this literal during build!

        // Unregister any old service workers with different script URLs
        // This handles cache busting when the hash in the filename changes
        // Pattern matches share-sw.js or share-sw-HASH.js
        const swPattern = /\/gb\/webshare\/share-sw(-[a-f0-9]+)?\.js$/;
        const registrations = await navigator.serviceWorker.getRegistrations();
        for (const reg of registrations) {
            const activeUrl = reg.active?.scriptURL;
            // If it's one of our SWs (matches pattern) but not the current version, unregister it
            if (activeUrl && swPattern.test(activeUrl) && !activeUrl.endsWith(swUrl)) {
                console.log('Unregistering old service worker:', activeUrl);
                await reg.unregister();
            }
        }

        var swRegistrationParams = {updateViaCache: 'all'};
        if (window.location.pathname !== '/gb/webshare/') { // detect github pages vs cf worker for sw scope
            swRegistrationParams.scope = '/';
        }
        const registration = await navigator.serviceWorker.register(swUrl, swRegistrationParams);

        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', function () {
                    if (this.state === 'activated') resolve();
                });
            });
        }

        if (!navigator.serviceWorker.controller) {
            // Wait for controllerchange, with timeout for hard reload edge case
            await Promise.race([
                new Promise(resolve => {
                    navigator.serviceWorker.addEventListener('controllerchange', resolve, {once: true});
                }),
                new Promise(resolve => setTimeout(resolve, 1000))
            ]);

            // If still no controller (hard reload), do a soft reload to let SW take control
            if (!navigator.serviceWorker.controller) {
                window.location.reload();
                // Block forever - page is reloading, don't let caller continue
                await new Promise(() => {});
            }
        }

        return registration;
    }

    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
        return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
    }

    let downloadErrored = false;
    function handleServiceWorkerMessage(event) {
        const data = event.data;
        console.log('[Page] SW message:', data.type, 'id:', data.id, 'expected:', messageId);
        if (data.id !== messageId) return; // ignore messages for other downloads

        if (data.type === 'progress') {
            if (downloadErrored) return; // don't overwrite error state
            // If we see progress, ensure UI reflects download in progress
            $('download').disabled = true;
            $('progress-container').style.display = 'block';
            $('status').style.display = 'block';
            $('status').className = '';
            $('status').textContent = 'Downloading... (check your browser\'s downloads)';
            const size = data.size;
            const pct = Math.min(100, (data.bytes / size) * 100);
            $('progress-fill').style.width = pct + '%';
            $('progress-text').textContent = `${formatBytes(data.bytes)} / ${formatBytes(size)} (${pct.toFixed(1)}%)`;
        } else if (data.type === 'complete') {
            $('progress-fill').style.width = '100%';
            if (data.id === messageId) {
                $('progress-container').style.display = 'none';
                showStatus('Download completed and verified ✓\n(check your browser\'s downloads)', 'success');
            }
        } else if (data.type === 'error') {
            downloadErrored = true;
            showStatus('Error: ' + data.message, 'error');
            $('progress-container').style.display = 'none';
            $('download').disabled = false;
        } else if (data.type === 'expired') {
            // Share has expired (detected during download/streaming)
            $('progress-container').style.display = 'none';
            showStatus(`This share link has expired at ${formatExpiredTime(data.expires_at)}. Ask the sender for a new link.`, 'error');
            $('download').disabled = true;
        }
    }

    // Start listening immediately to detect in-progress downloads
    navigator.serviceWorker?.addEventListener('message', handleServiceWorkerMessage);

    // Respond to SW asking for params (if SW was terminated and restarted)
    navigator.serviceWorker?.addEventListener('message', (event) => {
        if (event.data.type === 'need-params' && event.data.id === shortUrlKey) {
            // Send ALL params for range-based URL requests (not filtered params)
            // This ensures SW can handle requests for any file in the folder
            event.ports[0].postMessage({
                params: allParams || params,
                nonce: shareMetadata?.nonce,
                byteOffsets: shareMetadata?.byteOffsets
            });
        }
    });

    // Handle lepton decode requests from SW
    navigator.serviceWorker?.addEventListener('message', async (event) => {
        if (event.data.type === 'lepton-decode') {
            const { id, data } = event.data;
            const port = event.ports[0];

            try {
                await initLeptonWorker();

                // Copy data to ensure it's transferable (not backed by WASM memory)
                const dataCopy = new Uint8Array(data);

                // Send to worker and wait for response
                const result = await new Promise((resolve, reject) => {
                    const handler = (e) => {
                        if (e.data.id === id) {
                            leptonWorker.removeEventListener('message', handler);
                            if (e.data.error) {
                                reject(new Error(e.data.error));
                            } else {
                                resolve(e.data.result);
                            }
                        }
                    };
                    leptonWorker.addEventListener('message', handler);
                    leptonWorker.postMessage({ id, data: dataCopy }, [dataCopy.buffer]);
                });

                port.postMessage({ result }, [result.buffer]);
            } catch (error) {
                console.error('[Page] Lepton decode error:', error);
                port.postMessage({ error: error.message });
            }
        }
    });

    async function downloadFile() {
        $('download').disabled = true;
        showStatus('Making request to download...', '');

        try {
            await registerServiceWorker();
            await waitForSwIntercepting();

            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            iframe.src = downloadUrl;  // src AFTER appendChild (Firefox SW fix)

            setTimeout(() => iframe.remove(), 5000);

        } catch (e) {
            showStatus('Error: ' + e.message, 'error');
            $('progress-container').style.display = 'none';
            console.error(e);
            $('download').disabled = false;
        }
    }

    $('download').addEventListener('click', downloadFile);

    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        showStatus('Error: HTTPS required for Service Workers', 'error');
        $('download').disabled = true;
    } else if (isExpired && !shortUrlKey) {
        // Only block on expiry for static hash URLs; short URL mode fetches fresh URLs
        showStatus(`This share link has expired at ${formatExpiredTime(Math.floor(expiresAt / 1000))}. Ask the sender for a new link.`, 'error');
        $('download').disabled = true;
    }

    // Initialize service worker on page load so media can stream immediately
    // In short URL mode, always initialize since fresh URLs are fetched per request
    if (!isExpired || shortUrlKey) {
        (async () => {
            try {
                await registerServiceWorker();
                await waitForSwIntercepting();
                // Start loading lepton worker now that SW can proxy the files
                initLeptonWorker();
                if (params.length === 1) {
                    const mediaUrl = window.location.hash ?
                      `/gb/webshare/gb-download?${window.location.hash.slice(1)}`
                    : `/gb/webshare/gb-download?password=${params[0].shortUrlKey}&hash=${params[0].sha256}&media=true`;
                    showMediaPlayer(params[0].filename, mediaUrl, false, 'media-container');
                }
            } catch (e) {
                console.error('Failed to initialize service worker:', e);
            }
        })();
    }
    </script>
</body>
</html>
